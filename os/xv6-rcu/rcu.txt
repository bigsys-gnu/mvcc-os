ls.sym:24:0000064d rcureadlock
ls.sym:32:00000655 rcureadunlock
ls.sym:53:00000645 rcuwait
Binary file ulib.o matches
Binary file proc.o matches
Binary file rcu.o matches
Binary file usys.o matches
Binary file mp.o matches
Binary file console.o matches
Binary file _grep matches
mkdir.sym:23:00000397 rcureadlock
mkdir.sym:30:0000039f rcureadunlock
mkdir.sym:51:0000038f rcuwait
Binary file vm.o matches
.git/config:7:	url = https://github.com/sdharan/xv6-rcu.git
.git/logs/HEAD:1:0000000000000000000000000000000000000000 09e1ccf81e3dc516d3ef3c9317dcc2d0bf8f6750 Jaeho <jaeho@vt.edu> 1615879605 +0900	clone: from https://github.com/sdharan/xv6-rcu.git
.git/logs/refs/remotes/origin/HEAD:1:0000000000000000000000000000000000000000 09e1ccf81e3dc516d3ef3c9317dcc2d0bf8f6750 Jaeho <jaeho@vt.edu> 1615879605 +0900	clone: from https://github.com/sdharan/xv6-rcu.git
.git/logs/refs/heads/master:1:0000000000000000000000000000000000000000 09e1ccf81e3dc516d3ef3c9317dcc2d0bf8f6750 Jaeho <jaeho@vt.edu> 1615879605 +0900	clone: from https://github.com/sdharan/xv6-rcu.git
Binary file .git/index matches
Binary file .git/objects/pack/pack-ba37bb031327cde77279b42327ad4cea04fc7957.pack matches
usys.S:33:SYSCALL(rcuwait)
usys.S:34:SYSCALL(rcureadlock)
usys.S:35:SYSCALL(rcureadunlock)
sh.sym:24:00000f85 rcureadlock
sh.sym:34:00000f8d rcureadunlock
sh.sym:71:00000f7d rcuwait
Binary file _usertests matches
usertests.asm:6577:00003cab <rcuwait>:
usertests.asm:6578:SYSCALL(rcuwait)
usertests.asm:6583:00003cb3 <rcureadlock>:
usertests.asm:6584:SYSCALL(rcureadlock)
usertests.asm:6589:00003cbb <rcureadunlock>:
usertests.asm:6590:SYSCALL(rcureadunlock)
Binary file log.o matches
forktest.asm:660:00000412 <rcuwait>:
forktest.asm:661:SYSCALL(rcuwait)
forktest.asm:666:0000041a <rcureadlock>:
forktest.asm:667:SYSCALL(rcureadlock)
forktest.asm:672:00000422 <rcureadunlock>:
forktest.asm:673:SYSCALL(rcureadunlock)
Binary file rm.o matches
Binary file _wc matches
stressfs.asm:654:00000451 <rcuwait>:
stressfs.asm:655:SYSCALL(rcuwait)
stressfs.asm:660:00000459 <rcureadlock>:
stressfs.asm:661:SYSCALL(rcureadlock)
stressfs.asm:666:00000461 <rcureadunlock>:
stressfs.asm:667:SYSCALL(rcureadunlock)
testrcu.sym:12:00000000 testrcu.c
testrcu.sym:23:000004ce rcureadlock
testrcu.sym:30:000004d6 rcureadunlock
testrcu.sym:51:000004c6 rcuwait
rm.asm:588:0000038f <rcuwait>:
rm.asm:589:SYSCALL(rcuwait)
rm.asm:594:00000397 <rcureadlock>:
rm.asm:595:SYSCALL(rcureadlock)
rm.asm:600:0000039f <rcureadunlock>:
rm.asm:601:SYSCALL(rcureadunlock)
Binary file wc.o matches
Binary file ls.o matches
Binary file testshmget.o matches
syscall.h:24:#define SYS_rcuwait 23
syscall.h:25:#define SYS_rcureadlock 24
syscall.h:26:#define SYS_rcureadunlock 25
rcu.d:1:rcu.o: rcu.c /usr/include/stdc-predef.h types.h defs.h param.h x86.h \
rcu.d:2: memlayout.h mmu.h proc.h rcu.h
kill.asm:572:00000371 <rcuwait>:
kill.asm:573:SYSCALL(rcuwait)
kill.asm:578:00000379 <rcureadlock>:
kill.asm:579:SYSCALL(rcureadlock)
kill.asm:584:00000381 <rcureadunlock>:
kill.asm:585:SYSCALL(rcureadunlock)
Binary file bootblock.o matches
testshmget.asm:721:000004c1 <rcuwait>:
testshmget.asm:722:SYSCALL(rcuwait)
testshmget.asm:727:000004c9 <rcureadlock>:
testshmget.asm:728:SYSCALL(rcureadlock)
testshmget.asm:733:000004d1 <rcureadunlock>:
testshmget.asm:734:SYSCALL(rcureadunlock)
Binary file main.o matches
Binary file bootmain.o matches
kernel.asm:10130:[SYS_rcureadunlock] sys_rcureadunlock,
kernel.asm:12046:801062a2 <sys_rcuwait>:
kernel.asm:12048:sys_rcuwait(void)
kernel.asm:12053:    call_rcu();
kernel.asm:12054:801062a8:	e8 f6 21 00 00       	call   801084a3 <call_rcu>
kernel.asm:12061:801062b4 <sys_rcureadlock>:
kernel.asm:12063:sys_rcureadlock(void)
kernel.asm:12068:  rcu_read_lock();
kernel.asm:12069:801062ba:	e8 ae 21 00 00       	call   8010846d <rcu_read_lock>
kernel.asm:12076:801062c6 <sys_rcureadunlock>:
kernel.asm:12078:sys_rcureadunlock(void)
kernel.asm:12083:  rcu_read_unlock();
kernel.asm:12084:801062cc:	e8 b7 21 00 00       	call   80108488 <rcu_read_unlock>
kernel.asm:17120:8010846d <rcu_read_lock>:
kernel.asm:17123:#include "rcu.h"
kernel.asm:17125:void rcu_read_lock()
kernel.asm:17139:80108488 <rcu_read_unlock>:
kernel.asm:17141:void rcu_read_unlock()
kernel.asm:17155:801084a3 <call_rcu>:
kernel.asm:17157:void call_rcu()
kernel.asm:17166:801084b0:	eb 2e                	jmp    801084e0 <call_rcu+0x3d>
kernel.asm:17167:        cprintf ("\nInside call rcu setting proc allowed cpu to %d", i);
kernel.asm:17183:801084e4:	7e cc                	jle    801084b2 <call_rcu+0xf>
init.asm:624:00000400 <rcuwait>:
init.asm:625:SYSCALL(rcuwait)
init.asm:630:00000408 <rcureadlock>:
init.asm:631:SYSCALL(rcureadlock)
init.asm:636:00000410 <rcureadunlock>:
init.asm:637:SYSCALL(rcureadunlock)
Binary file kill.o matches
Binary file _rm matches
Binary file _kill matches
grep.asm:899:0000062a <rcuwait>:
grep.asm:900:SYSCALL(rcuwait)
grep.asm:905:00000632 <rcureadlock>:
grep.asm:906:SYSCALL(rcureadlock)
grep.asm:911:0000063a <rcureadunlock>:
grep.asm:912:SYSCALL(rcureadunlock)
Binary file sh.o matches
wc.asm:706:000004bc <rcuwait>:
wc.asm:707:SYSCALL(rcuwait)
wc.asm:712:000004c4 <rcureadlock>:
wc.asm:713:SYSCALL(rcureadlock)
wc.asm:718:000004cc <rcureadunlock>:
wc.asm:719:SYSCALL(rcureadunlock)
Binary file _zombie matches
zombie.sym:23:00000333 rcureadlock
zombie.sym:30:0000033b rcureadunlock
zombie.sym:51:0000032b rcuwait
echo.sym:23:0000036c rcureadlock
echo.sym:30:00000374 rcureadunlock
echo.sym:51:00000364 rcuwait
Binary file _echo matches
stressfs.sym:23:00000459 rcureadlock
stressfs.sym:30:00000461 rcureadunlock
stressfs.sym:51:00000451 rcuwait
Binary file exec.o matches
sysproc.c:106:sys_rcuwait(void)
sysproc.c:108:    call_rcu();
sysproc.c:112:sys_rcureadlock(void)
sysproc.c:114:  rcu_read_lock();
sysproc.c:118:sys_rcureadunlock(void)
sysproc.c:120:  rcu_read_unlock();
Binary file syscall.o matches
cat.asm:644:0000040e <rcuwait>:
cat.asm:645:SYSCALL(rcuwait)
cat.asm:650:00000416 <rcureadlock>:
cat.asm:651:SYSCALL(rcureadlock)
cat.asm:656:0000041e <rcureadunlock>:
cat.asm:657:SYSCALL(rcureadunlock)
rm.sym:23:00000397 rcureadlock
rm.sym:30:0000039f rcureadunlock
rm.sym:51:0000038f rcuwait
Binary file file.o matches
Binary file kernel matches
cat.sym:23:00000416 rcureadlock
cat.sym:30:0000041e rcureadunlock
cat.sym:53:0000040e rcuwait
kernel.sym:137:00000000 rcu.c
kernel.sym:148:801062b4 sys_rcureadlock
kernel.sym:273:801062a2 sys_rcuwait
kernel.sym:452:801062c6 sys_rcureadunlock
kernel.sym:462:801084a3 call_rcu
kernel.sym:576:80108488 rcu_read_unlock
kernel.sym:580:8010846d rcu_read_lock
Binary file ln.o matches
wc.sym:23:000004c4 rcureadlock
wc.sym:30:000004cc rcureadunlock
wc.sym:53:000004bc rcuwait
Binary file printf.o matches
Binary file lapic.o matches
defs.h:180:// rcu.h
defs.h:181:void rcu_read_lock(void);
defs.h:182:void rcu_read_unlock(void);
defs.h:183:void call_rcu (void);
Binary file pipe.o matches
ls.asm:868:00000645 <rcuwait>:
ls.asm:869:SYSCALL(rcuwait)
ls.asm:874:0000064d <rcureadlock>:
ls.asm:875:SYSCALL(rcureadlock)
ls.asm:880:00000655 <rcureadunlock>:
ls.asm:881:SYSCALL(rcureadunlock)
testrcu.d:1:testrcu.o: testrcu.c /usr/include/stdc-predef.h types.h stat.h user.h \
testshmget.sym:23:000004c9 rcureadlock
testshmget.sym:30:000004d1 rcureadunlock
testshmget.sym:51:000004c1 rcuwait
Binary file _init matches
Binary file sysproc.o matches
Binary file swtch.o matches
Binary file kbd.o matches
usertests.sym:25:00003cb3 rcureadlock
usertests.sym:36:00003cbb rcureadunlock
usertests.sym:85:00003cab rcuwait
Binary file grep.o matches
init.sym:23:00000408 rcureadlock
init.sym:31:00000410 rcureadunlock
init.sym:52:00000400 rcuwait
Binary file stressfs.o matches
ln.sym:23:0000037b rcureadlock
ln.sym:30:00000383 rcureadunlock
ln.sym:51:00000373 rcuwait
Binary file usertests.o matches
Binary file uart.o matches
Binary file entryother.o matches
Binary file string.o matches
Binary file vectors.o matches
ln.asm:574:00000373 <rcuwait>:
ln.asm:575:SYSCALL(rcuwait)
ln.asm:580:0000037b <rcureadlock>:
ln.asm:581:SYSCALL(rcureadlock)
ln.asm:586:00000383 <rcureadunlock>:
ln.asm:587:SYSCALL(rcureadunlock)
Binary file ide.o matches
Binary file init.o matches
Binary file initcode.out matches
syscall.c:102:extern int sys_rcuwait(void);
syscall.c:103:extern int sys_rcureadunlock(void);
syscall.c:104:extern int sys_rcureadlock(void);
syscall.c:129:[SYS_rcuwait] sys_rcuwait,
syscall.c:130:[SYS_rcureadlock] sys_rcureadlock,
syscall.c:131:[SYS_rcureadunlock] sys_rcureadunlock,
user.h:26:int rcuwait(void);
user.h:27:int rcureadlock(void);
user.h:28:int rcureadunlock(void);
Binary file trapasm.o matches
Binary file spinlock.o matches
Binary file ioapic.o matches
zombie.asm:543:0000032b <rcuwait>:
zombie.asm:544:SYSCALL(rcuwait)
zombie.asm:549:00000333 <rcureadlock>:
zombie.asm:550:SYSCALL(rcureadlock)
zombie.asm:555:0000033b <rcureadunlock>:
zombie.asm:556:SYSCALL(rcureadunlock)
Binary file fs.img matches
Binary file forktest.o matches
Binary file timer.o matches
rcu.c:8:#include "rcu.h"
rcu.c:10:void rcu_read_lock()
rcu.c:15:void rcu_read_unlock()
rcu.c:20:void call_rcu()
rcu.c:25:        cprintf ("\nInside call rcu setting proc allowed cpu to %d", i);
Binary file bootasm.o matches
Binary file .mkfs.c.swp matches
Binary file umalloc.o matches
Binary file _cat matches
Binary file bootblockother.o matches
Binary file sysfile.o matches
Binary file cat.o matches
sh.asm:2053:00000f7d <rcuwait>:
sh.asm:2054:SYSCALL(rcuwait)
sh.asm:2059:00000f85 <rcureadlock>:
sh.asm:2060:SYSCALL(rcureadlock)
sh.asm:2065:00000f8d <rcureadunlock>:
sh.asm:2066:SYSCALL(rcureadunlock)
Binary file testrcu.o matches
testrcu.asm:2:_testrcu:     file format elf32-i386
testrcu.asm:92:    rcureadlock();
testrcu.asm:93:  c1:	e8 08 04 00 00       	call   4ce <rcureadlock>
testrcu.asm:141:    rcureadunlock();
testrcu.asm:142: 141:	e8 90 03 00 00       	call   4d6 <rcureadunlock>
testrcu.asm:151:    printf(1,"Parent: Calling rcuwait to wait for safe update\n");
testrcu.asm:157:    rcuwait();
testrcu.asm:158: 167:	e8 5a 03 00 00       	call   4c6 <rcuwait>
testrcu.asm:706:000004c6 <rcuwait>:
testrcu.asm:707:SYSCALL(rcuwait)
testrcu.asm:712:000004ce <rcureadlock>:
testrcu.asm:713:SYSCALL(rcureadlock)
testrcu.asm:718:000004d6 <rcureadunlock>:
testrcu.asm:719:SYSCALL(rcureadunlock)
Binary file _ls matches
Makefile:30:	rcu.o\
Makefile:175:	_testrcu\
Binary file _forktest matches
Binary file initcode.o matches
mkdir.asm:588:0000038f <rcuwait>:
mkdir.asm:589:SYSCALL(rcuwait)
mkdir.asm:594:00000397 <rcureadlock>:
mkdir.asm:595:SYSCALL(rcureadlock)
mkdir.asm:600:0000039f <rcureadunlock>:
mkdir.asm:601:SYSCALL(rcureadunlock)
Binary file _testrcu matches
README.txt:13:With the above two changes, we can enable a very basic version of RCU, albeit a version where the writer may wait for a period that is greater than that is strictly required. Every time a process enters the critical section and reads a shared object, it notifies the cpu to not preempt it by calling the system call rcureadlock(), which internally sets the cpu preempt_disable_count to greater than zero. Every time the process leaves the read critical section, it unlocks the critical section by calling rcureadunlock() system call, which enables preemption of the process. 
README.txt:15:When a writer wants to update the critical section, the writer process has to call rcuwait() which will wait for a period which ensures no readers are reading the shared object and returns. The writer can update the object as soon as rcuwait returns. rcuwait() system call internally works by setting the processor affinity incrementally to all processors from 0 to NCPU. This means that the process has to execute in all the processors before returning. Since any reader in the critial section would typically disable preemption in the critical section, this mechanism ensures that all readers are outside the critical section. The rcu wait system call simply returns as soon as it executes once in all the processors. 
README.txt:21:In order to test this, i wrote a uprog called testrcu which basically does this
README.txt:24:2) In child, read the memory for a long period in critical section after enabling it through rcureadlock()
README.txt:25:3) In parent, call rcuwait() to wait for the readers to finish before updating memory to 'B's
README.txt:28:If there is no rcuwait() in the parent,, then the child is written to throw errors as soon as it reads a value which is not a 'A'.
grep.sym:23:00000632 rcureadlock
grep.sym:31:0000063a rcureadunlock
grep.sym:55:0000062a rcuwait
Binary file _ln matches
Binary file picirq.o matches
Binary file kalloc.o matches
Binary file zombie.o matches
Binary file echo.o matches
Binary file bio.o matches
Binary file _stressfs matches
Binary file mkdir.o matches
kill.sym:23:00000379 rcureadlock
kill.sym:30:00000381 rcureadunlock
kill.sym:51:00000371 rcuwait
Binary file entry.o matches
Binary file _mkdir matches
Binary file _testshmget matches
Binary file trap.o matches
Binary file fs.o matches
echo.asm:565:00000364 <rcuwait>:
echo.asm:566:SYSCALL(rcuwait)
echo.asm:571:0000036c <rcureadlock>:
echo.asm:572:SYSCALL(rcureadlock)
echo.asm:577:00000374 <rcureadunlock>:
echo.asm:578:SYSCALL(rcureadunlock)
testrcu.c:34:    rcureadlock();
testrcu.c:47:    rcureadunlock();
testrcu.c:51:    printf(1,"Parent: Calling rcuwait to wait for safe update\n");
testrcu.c:52:    rcuwait();
Binary file xv6.img matches
Binary file _sh matches
